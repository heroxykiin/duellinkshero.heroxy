// Note: This file has been modified for purpose of this site.   

/*
 * TouchScroll - using dom overflow:scroll
 * by kmturley
 */

/* globals window, document */

var TouchScroll = function () {
    'use strict';
    
    var module = {
        axis: 'x',
        drag: false,
        zoom: 1,
        time: 0.04,
        isIE: window.navigator.userAgent.toLowerCase().indexOf('msie') > -1,
        isFirefox: window.navigator.userAgent.toLowerCase().indexOf('firefox') > -1,
        /**
         * @method init
         */
        init: function (options) {
            var me = this;
            this.options = options;
            
            this.el = options.el;

            // if draggable option is enabled add events
            if (options.draggable === true) {
                if (this.isIE) {
                    document.ondragstart = function () { return false; };
                }
                if (this.isIE || this.isFirefox) {
                    this.body = document.documentElement;
                } else {
                    this.body = document.body;
                }
                this.addEvent('mousedown', this.el, function (e) { me.onMouseDown(e); });
                this.addEvent('mousemove', this.el, function (e) { me.onMouseMove(e); });
                this.addEvent('mouseup', this.body, function (e) { me.onMouseUp(e); });
            }
            
            // if zoom option exists add mouse wheel functionality to element
            if (options && options.zoom) {
                this.elzoom = document.getElementById(options.zoom);
                if (this.isFirefox) {
                    this.addEvent('DOMMouseScroll', this.el, function (e) { me.onMouseWheel(e); });
                } else {
                    this.addEvent('mousewheel', this.el, function (e) { me.onMouseWheel(e); });
                }
            }
            
            // if scroll options exist add events
            if (options && options.prev) {
                this.prev = document.getElementById(options.prev);
                this.addEvent('mousedown', this.prev, function (e) {
                    me.onMouseDown(e);
                });
                this.addEvent('mouseup', this.prev, function (e) {
                    me.diffx = options.distance ? (-options.distance / 11) : -11;
                    me.onMouseUp(e);
                });
            }
            if (options && options.next) {
                this.next = document.getElementById(options.next);
                this.addEvent('mousedown', this.next, function (e) {
                    me.onMouseDown(e);
                });
                this.addEvent('mouseup', this.next, function (e) {
                    me.diffx = options.distance ? (options.distance / 11) : 11;
                    me.onMouseUp(e);
                });
            }
        },
        /**
         * @method addEvent
         */
        addEvent: function (name, el, func) {
            if (el.addEventListener) {
                el.addEventListener(name, func, false);
            } else if (el.attachEvent) {
                el.attachEvent('on' + name, func);
            } else {
                el[name] = func;
            }
        },
        /**
         * @method cancelEvent
         */
        cancelEvent: function (e) {
            if (!e) { e = window.event; }
            if (e.target && e.target.nodeName === 'IMG') {
                e.preventDefault();
            } else if (e.srcElement && e.srcElement.nodeName === 'IMG') {
                e.returnValue = false;
            }
        },
        /**
         * @method onMouseDown
         */
        onMouseDown: function (e) {
            if (this.drag === false || this.options.wait === false) {
                this.drag = true;
                this.cancelEvent(e);
                this.startx = e.clientX + this.el.scrollLeft;
                this.starty = e.clientY + this.el.scrollTop;
                this.diffx = 0;
                this.diffy = 0;
            }
        },
        /**
         * @method onMouseMove
         */
        onMouseMove: function (e) {
            if (this.drag === true) {
                this.cancelEvent(e);
                this.diffx = (this.startx - (e.clientX + this.el.scrollLeft));
                this.diffy = (this.starty - (e.clientY + this.el.scrollTop));
                this.el.scrollLeft += this.diffx;
                this.el.scrollTop += this.diffy;
            }
        },
        /**
         * @method onMouseMove
         */
        onMouseUp: function (e) {
            if (this.drag === true) {
                if (!this.options.wait) {
                    this.drag = null;
                }
                this.cancelEvent(e);
                var me = this,
                    start = 1,
                    animate = function () {
                        //var step = Math.sin(start);
                        var step = Math.pow(Math.E, -Math.pow(start - 1, 2)); // Gaussian Function shifted 1 unit to the right
                        if (step <= 0) {
                            me.diffx = 0;
                            me.diffy = 0;
                            window.cancelAnimationFrame(animate);
                            me.drag = false;
                        } else {
                            me.el.scrollLeft += me.diffx * step;
                            me.el.scrollTop += me.diffy * step;
                            start -= me.time;
                            window.requestAnimationFrame(animate);
                        }
                    };
                animate();
            }
        },
        /**
         * @method onMouseMove
         */
        onMouseWheel: function (e) {
            this.cancelEvent(e);
            if (e.detail) {
                this.zoom -= e.detail;
            } else {
                this.zoom += (e.wheelDelta / 1200);
            }
            if (this.zoom < 1) {
                this.zoom = 1;
            } else if (this.zoom > 10) {
                this.zoom = 10;
            }
            /*
            this.elzoom.style.OTransform = 'scale(' + this.zoom + ', ' + this.zoom + ')';
            this.elzoom.style.MozTransform = 'scale(' + this.zoom + ', ' + this.zoom + ')';
            this.elzoom.style.msTransform = 'scale(' + this.zoom + ', ' + this.zoom + ')';
            this.elzoom.style.WebkitTransform = 'scale(' + this.zoom + ', ' + this.zoom + ')';
            this.elzoom.style.transform = 'scale(' + this.zoom + ', ' + this.zoom + ')';
            */
            this.elzoom.style.zoom = this.zoom * 100 + '%';
            //this.el.scrollLeft += e.wheelDelta / 10;
            //this.el.scrollTop += e.wheelDelta / 8;
        }
    };
    return module;
};

$(function(){
    var imageSliders = $('.image-slider');
    imageSliders.each(function(index, imageSlider) {
        var slider = new TouchScroll();
        slider.init({
            el: $(imageSlider)[0],
            draggable: true,
            wait: false
        });
    });    
});;
$(document).ready(function()
{
    ExecuteOnReadyFunctions();
    BindPageEvents();
	
    $('.carousel').carousel({
        interval: false
	});
	
    setImageFilter();
});

function ExecuteOnReadyFunctions()
{
    ReadUrlHashFragment();
}

function BindPageEvents()
{
    BindTabsToUrlHash();
    BindCollapsableTables();
    BindSeasonArchiveSelection();
}

function ReadUrlHashFragment()
{
    var hash = window.location.hash;
    
    if (hash !== "")
    {
        $.when( $(".nav-tabs a[href='" + hash + "']").tab("show") ).then(function( ) { $(".page-wrapper").scrollTop(0); });
        /*$(".nav-tabs a[href='" + hash + "']").tab("show");
		$(".page-wrapper").scrollTop(0);*/
	} 
}

function BindTabsToUrlHash()
{
    $(document).on("shown.bs.tab", "a[data-toggle='tab']", function(event)
    {
        var position = $(".page-wrapper").scrollTop();
        window.location.hash = event.target.hash;
        $(".page-wrapper").scrollTop(position);
	});
}

function BindCollapsableTables()
{
    $("table.collapsable").each(function(index, elem)
    {
        $(elem).find("thead").click(function()
        {
            $(elem).toggleClass("collapsed");
		});
	});
}

function BindSeasonArchiveSelection()
{
    $("#SeasonArchiveSelection").change(function(event)
    {
        if($(event.target).val() != 'defaultValue') window.location = "/top-decks/" + $(event.target).val();
	});
}

function EventComplete()
{
    $(".soon-event-countdown").addClass("hidden");
    $(".soon-event-complete").removeClass("hidden");
}

function getWebsiteLink() {
    var websiteLink = location.protocol + "//" + location.hostname;
    if(location.port) {
        websiteLink += ":" + location.port;
	}
    return websiteLink;
}

//menubutton script
function toggleChange(elem)
{
    elem.classList.toggle("change");
}

function setImageFilter() {
    new CardsAPI().setImageFilters();
}

function twitchNotification() {
    //test if user has already seen this here
    
    
    // Get the snackbar DIV
    var x = document.getElementById("snackbar")
	
    // Add the "show" class to DIV
    x.className = "show";
	
    // After 3 seconds, remove the show class from DIV
    setTimeout(function(){ x.className = x.className.replace("show", ""); }, 7000);
}




if (!sessionStorage.run3times || sessionStorage.run3times<3) {
    if(!sessionStorage.run3times){
        sessionStorage.run3times = 1;
		}else{
        sessionStorage.run3times++;
	}
	$.getJSON("https://api.twitch.tv/kraken/streams/duellinksmeta?client_id=ajtf58zc6vxrkaf7faohw5al9v3tua", function(channel)
	{
		if (channel["stream"] == null)
		{
			return;
			} else {
			twitchNotification();
		}
	});
}

if (typeof antiabd === 'undefined')
{
    //you can view the site 3x with adblock but no more after that.
    if (localStorage.ABDrun3times < 3)
    {
        if(!localStorage.ABDrun3times)
            localStorage.ABDrun3times = 1;
        else
            localStorage.ABDrun3times++;
    }
    else
    {
        window.location = "/advertisements-info/";
    }
}
//remove disqus ads script
(function($){
    setInterval(() => {
        $.each($('iframe'), (arr,x) => {
            let src = $(x).attr('src');
            if (src && src.match(/(ads-iframe)|(disqusads)/gi)) {
                $(x).remove();
            }
        });
    }, 300);
})(jQuery);;
// TODO: Rename this since the skill API is added? 

/* 
 * This API is used to access a card's data
 */ 
function CardsAPI() { 

    // TODO: Rename this since the skill API is added? 

    /*
     * This function searches a given card name and returns its information
     * using the Card object.  
     * 
     * @param cardName The name of the card to search
     * @param callback Function to execute once the data is retrieved
     * 
     * @return Card An object containing the information, if available (if not, the 
     *              object will be null)
     * 
     * Card - This is object is used to store the data retrieved from a card search    
     *  
     * name The name of the card 
     * rarity A card's rarity value (i.e. 'N' for Normal, 'UR' for Ultra Rare, etc.)
     * attribute A card's attribute value (i.e. 'Wind', 'Light', etc.)
     * level The amount of stars a card has (only applies to monster type cards)
     * materials The monsters needed to summon this card (fusion materials)
     * description The description of the card
     * type A card's type (i.e. 'Spell', 'Trap', "Winged Beast", etc.)
     * attack A card's attack points (only applies to monsters)
     * defense A card's defense points (only applies to monsters)
     * obtain How/where to obtain this card within the game (if not available, 
     *        the phrase 'Needs to be Added' will be placed inside); in addition,
     *        this value is an array, so if more than one location is available, it
     *        will be inserted   
     */  
    this.search = function(cardName, callback) {
        let cardobtain = $.getJSON("/data/cardObtain.json").then(function(r) {
            if(r) {
                var filteredCards = [];
                $(r).each(function(index, card) {
                    if(card.name == cardName) {
                        filteredCards.push(card);
                    }
                });
                return filteredCards;
            }
            else {
                return [];
            }
        });
        let cardinfo = JSON.parse(sessionStorage.getItem(cardName));
        
        var cardNameEncoded = encodeURIComponent(cardName);
        if (!cardinfo) {
            cardinfo = $.getJSON("https://query.yahooapis.com/v1/public/yql", {
                q:      "select * from json where url=\"https://yugiohprices.com/api/card_data/" + cardNameEncoded + "?fmt=JSON\"",
                format: "json"
            }).then(function(r) {
                sessionStorage.setItem(cardName, JSON.stringify(r.query.results.json));
                return r.query.results.json;
            });
        }
        
        var self = this;
        Promise.all([cardobtain, cardinfo]).then(function(response) {
            var card = new Object();

            self.obtainCardData = response[1];
            self.obtainCardName = cardName;

            card.name = cardName;
            card.rarity = response[0].length > 0 ? response[0][0].rarity : "";
            card.attribute = self.obtainCardProperty('family') != 'null' ? self.obtainCardProperty('family') : "";
            card.level = self.obtainCardProperty('level') != 'null' ? self.obtainCardProperty('level') : "";
            if(self.obtainCardProperty('type') && self.obtainCardProperty('type').includes("Fusion")) {
                var cardTextArray = self.obtainCardProperty('text').split('\n');
                card.materials = cardTextArray[0];
                card.description = cardTextArray[2];
            } 
            else {
                card.description = self.obtainCardProperty('text');
                card.materials = "";
            }
            if(self.obtainCardProperty('card_type') == "monster") {
                card.type = self.obtainCardProperty('type');
            }
            else {
                card.type = self.obtainCardProperty('card_type') + " / " + self.obtainCardProperty('property');
            }
            card.attack = self.obtainCardProperty('atk') != 'null' ? self.obtainCardProperty('atk') : "";
            card.defense = self.obtainCardProperty('def') != 'null' ? self.obtainCardProperty('def') : "";
            if(response[0].length > 0) {
                card.obtain = [];
                $(response[0]).each(function(index, obtainCard) {
                    card.obtain.push(obtainCard.how);
                }); 
            }
            else {
                card.obtain = ["Needs to be Added"];
            }

            callback(card);    
        });
    },

    /*
     * This function is used to search for a skill, returning the findings 
     * through a callback function. 
     * 
     * @param skillName - The name of the skill to be searched
     * @param callback - The function to return the data, once searched
     * 
     * @return Skill - Object containing the information of the skill; if 
     *                 not found, null is returned 
     * 
     * Skill - This object contains a list of parameters for a skill
     * 
     * name - Name of the skill
     * description - Description of the skill  
     * exclusive - Whether or not this skill is exclusive to a character (true/false)
     * character - If the skill is exclusive, then this will be the name of the that character (else, empty string) 
     * imageURL - URL to obtain the image of the skill, depending on its exclusivity
     */ 
    this.searchSkill = function(skillName, callback) {
        $.getJSON(getWebsiteLink() + "/data/skills.json").then( function( response ) {
            var skill = new Object();
            for(var i = 0; i < response.length; i++) {
                if(response[i].name.replace(/[^a-zA-Zα-ωΑ-Ω ]/g, "").toLowerCase() == skillName.replace(/[^a-zA-Zα-ωΑ-Ω ]/g, "").toLowerCase()) {
                    skill.name = response[i].name;
                    skill.description = response[i].desc;
                    skill.exclusive = response[i].exclusive;
                    skill.character = response[i].character;                       

                    break;
                }
            }
            
            if(skill.name.length == 0) {
                // Skill not found, return null
                callback(null);
            }
            else {
                skill.imageURL = getWebsiteLink() + "/img/characters/portrait-" + (skill.exclusive == true ? skill.character.toLowerCase().replace(" ", "-"): 'vagabond') + ".png";
                callback(skill);
            }
        });    
    },

    /*
     * This function iterates through each image on the page and updates its
     * 'src' location depending on an array of card names that need a localized
     * image.
     */  
    this.setImageFilters = function() {
        var self = this;
        $('.item img.dcards').each(function( index, element ) {
            if($(element).attr('src') != undefined && $(element).attr('src').includes('https://images.weserv.nl/?url=yugiohprices.com/api/card_image/')) {
                var slicedSrc = $(element).attr('src').replace("https://images.weserv.nl/?url=yugiohprices.com/api/card_image/", "").replace("&il", "");
                var cardName = decodeURIComponent(slicedSrc);
                var updatedURL = self.getImageURL(cardName);
                if(updatedURL != $(element).attr('src')) {
                    $(element).attr('src', updatedURL);
                }
            }
        });
    },

    /*
     * This function returns a URL to obtain an image from, given a 
     * card name. 
     * 
     * @param cardName Name of the card
     * 
     * @return String URL of the for the image
     */ 
    this.getImageURL = function( cardName ) {
        for(var index = 0; index < this.filters.length; index++) {
            if(this.filters[index].name == cardName) {
                return this.filters[index].customURL;
            }    
        }    

        return "https://images.weserv.nl/?url=yugiohprices.com/api/card_image/" + encodeURIComponent(cardName) + '&il';
    },

    /*
     * List of card image that need to be updated due to its 
     * incorrect image from the default server 
     * 
     * (Note: This object should be treated as private)
     * 
     * name Name of the card
     * customURL String representation of the URL to obtain this image from
     */ 
    this.filters = [
        {
            name: "Enchanted Javelin",
            customURL: "/img/cards/enchantedJavelin.jpg"
        },
        {
            name: "Hey, Trunade!",
            customURL: "/img/cards/heytrunade.jpg"
        },
        {
            name: "Mega Ultra Chicken",
            customURL: "/img/cards/megaultrachicken.jpg"
        }
    ],

    /*
     * List of card data that was either errated for the game or the API 
     * used to obtain this data does not contain it. All properties of 
     * the cards mimic the data within 'search' function
     * 
     * (Note: This object should be treated as private)
     */ 
    this.cardFilters = [
        {
            name: "Return",
            card_type: "Trap",
            property: "Normal",
            text: "When your opponent adds a card(s) from the Graveyard to their hand: They must shuffle 1 of those cards into their Deck." 
        },
        {
            name: "Mega Ultra Chicken",
            card_type: "Monster",
            property: "Effect",
            text: "Arise, chicken, Arise!" 
        }
    ],

    /*
     * Used in the 'obtainCardProperty' method for the returned card 
     * data from the API 
     * 
     * (Note: This object should be treated as private)
     */ 
    this.obtainCardData = [],

    /*
     * This object is used by the 'obtainCardProperty' as the card 
     * searched against for the filter 
     * 
     * (Note: This object should be treated as private)
     */ 
    this.obtainCardName = "",

    /*
     * This method returns the asked property of a card, whether it was
     * derived from the given data array or a custom array of data for 
     * that card 
     * 
     * (Note: This method should be treated as private, as it needs the
     * returned card data to function)   
     * 
     * @param property String representation of the property asked 
     */ 
    this.obtainCardProperty = function(property) {
        var self = this;
        var cardProperty; 
        $(this.cardFilters).each(function(index, card) {
            if(self.obtainCardName == card.name) {
                cardProperty = card[property];
                return false;
            }
        });
        if(cardProperty) return cardProperty;

        if(this.obtainCardData['data']) {
            return this.obtainCardData.data[property];
        }
        else {
            return "null";
        }
    }
};;
